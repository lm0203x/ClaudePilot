const { app, BrowserWindow, ipcMain, dialog } = require('electron');
const fs = require('fs');
const path = require('path');
const os = require('os');

let mainWindow;

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false
    },
    icon: path.join(__dirname, 'assets', 'icon.png'),
    title: 'ClaudePilot - Claude Code å¯è§†åŒ–å·¥å…·'
  });

  mainWindow.loadFile('index.html');

  if (process.argv.includes('--dev')) {
    mainWindow.webContents.openDevTools();
  }
}

// èŽ·å–Claudeé…ç½®æ–‡ä»¶è·¯å¾„
function getClaudeConfigPath() {
  const home = os.homedir();
  return path.join(home, '.claude.json');
}

// èŽ·å–Claudeè®¾ç½®æ–‡ä»¶è·¯å¾„
function getClaudeSettingsPath() {
  const home = os.homedir();
  return path.join(home, '.claude', 'settings.json');
}

// Provider æ¨¡æ¿ - åŒ¹é… settings.json æ ¼å¼
const PROVIDER_TEMPLATES = {
  claude: {
    name: 'Claude',
    icon: 'ðŸ¤–',
    fields: {
      "ANTHROPIC_BASE_URL": "https://api.anthropic.com",
      "ANTHROPIC_MODEL": "claude-3-5-sonnet-20241022",
      "ANTHROPIC_DEFAULT_HAIKU_MODEL": "claude-3-5-haiku-20241022",
      "ANTHROPIC_DEFAULT_OPUS_MODEL": "claude-3-opus-20240229",
      "ANTHROPIC_DEFAULT_SONNET_MODEL": "claude-3-5-sonnet-20241022",
      "ANTHROPIC_SMALL_FAST_MODEL": "claude-3-haiku-20240307",
      "ANTHROPIC_API_KEY": "{{API_KEY}}",
      "ANTHROPIC_AUTH_TOKEN": "{{API_KEY}}"
    }
  },
  glm: {
    name: 'GLM',
    icon: 'ðŸ§ ',
    fields: {
      "ANTHROPIC_BASE_URL": "https://open.bigmodel.cn/",
      "ANTHROPIC_MODEL": "GLM-4.6",
      "ANTHROPIC_DEFAULT_HAIKU_MODEL": "GLM-4.5-Air",
      "ANTHROPIC_DEFAULT_OPUS_MODEL": "GLM-4.6",
      "ANTHROPIC_DEFAULT_SONNET_MODEL": "GLM-4.6",
      "ANTHROPIC_SMALL_FAST_MODEL": "",
      "ANTHROPIC_API_KEY": "{{API_KEY}}",
      "ANTHROPIC_AUTH_TOKEN": "{{API_KEY}}"
    }
  },
  kimi: {
    name: 'Kimi',
    icon: 'ðŸŒ™',
    fields: {
      "ANTHROPIC_BASE_URL": "https://api.moonshot.cn/v1",
      "ANTHROPIC_MODEL": "moonshot-v1-32k",
      "ANTHROPIC_DEFAULT_HAIKU_MODEL": "moonshot-v1-8k",
      "ANTHROPIC_DEFAULT_OPUS_MODEL": "moonshot-v1-128k",
      "ANTHROPIC_DEFAULT_SONNET_MODEL": "moonshot-v1-32k",
      "ANTHROPIC_SMALL_FAST_MODEL": "moonshot-v1-8k",
      "ANTHROPIC_API_KEY": "{{API_KEY}}",
      "ANTHROPIC_AUTH_TOKEN": "{{API_KEY}}"
    }
  },
  openai: {
    name: 'OpenAI',
    icon: 'ðŸ”·',
    fields: {
      "ANTHROPIC_BASE_URL": "https://api.openai.com/v1",
      "ANTHROPIC_MODEL": "gpt-4-turbo",
      "ANTHROPIC_DEFAULT_HAIKU_MODEL": "gpt-3.5-turbo",
      "ANTHROPIC_DEFAULT_OPUS_MODEL": "gpt-4-turbo",
      "ANTHROPIC_DEFAULT_SONNET_MODEL": "gpt-4",
      "ANTHROPIC_SMALL_FAST_MODEL": "gpt-3.5-turbo",
      "ANTHROPIC_API_KEY": "{{API_KEY}}",
      "ANTHROPIC_AUTH_TOKEN": "{{API_KEY}}"
    }
  },
  deepseek: {
    name: 'DeepSeek',
    icon: 'ðŸ”¬',
    fields: {
      "ANTHROPIC_BASE_URL": "https://api.deepseek.com/v1",
      "ANTHROPIC_MODEL": "deepseek-chat",
      "ANTHROPIC_DEFAULT_HAIKU_MODEL": "deepseek-chat",
      "ANTHROPIC_DEFAULT_OPUS_MODEL": "deepseek-chat",
      "ANTHROPIC_DEFAULT_SONNET_MODEL": "deepseek-chat",
      "ANTHROPIC_SMALL_FAST_MODEL": "",
      "ANTHROPIC_API_KEY": "{{API_KEY}}",
      "ANTHROPIC_AUTH_TOKEN": "{{API_KEY}}"
    }
  }
};

// IPC å¤„ç†å™¨
ipcMain.handle('load-settings', async () => {
  try {
    const settingsPath = getClaudeSettingsPath();
    if (fs.existsSync(settingsPath)) {
      const data = fs.readFileSync(settingsPath, 'utf8');
      return JSON.parse(data);
    } else {
      // è¿”å›žé»˜è®¤è®¾ç½®
      return {
        profiles: []
      };
    }
  } catch (error) {
    console.error('åŠ è½½è®¾ç½®å¤±è´¥:', error);
    throw error;
  }
});

ipcMain.handle('load-mcp-config', async () => {
  try {
    const mcpPath = getClaudeConfigPath();
    if (fs.existsSync(mcpPath)) {
      const data = fs.readFileSync(mcpPath, 'utf8');
      return JSON.parse(data);
    } else {
      // è¿”å›žé»˜è®¤MCPé…ç½®
      return {
        mcpServers: {}
      };
    }
  } catch (error) {
    console.error('åŠ è½½MCPé…ç½®å¤±è´¥:', error);
    throw error;
  }
});

ipcMain.handle('save-settings', async (event, settings) => {
  try {
    const settingsPath = getClaudeSettingsPath();
    const settingsDir = path.dirname(settingsPath);

    // ç¡®ä¿ç›®å½•å­˜åœ¨
    if (!fs.existsSync(settingsDir)) {
      fs.mkdirSync(settingsDir, { recursive: true });
    }

    fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2));
    return true;
  } catch (error) {
    console.error('ä¿å­˜è®¾ç½®å¤±è´¥:', error);
    throw error;
  }
});

ipcMain.handle('save-mcp-config', async (event, mcpConfig) => {
  try {
    const mcpPath = getClaudeConfigPath();

    fs.writeFileSync(mcpPath, JSON.stringify(mcpConfig, null, 2));
    return true;
  } catch (error) {
    console.error('ä¿å­˜MCPé…ç½®å¤±è´¥:', error);
    throw error;
  }
});

ipcMain.handle('get-provider-templates', async () => {
  return Object.entries(PROVIDER_TEMPLATES).map(([key, template]) => ({
    key,
    ...template
  }));
});

ipcMain.handle('test-connection', async (event, config) => {
  try {
    const axios = require('axios');

    // æž„å»ºæµ‹è¯•è¯·æ±‚
    const testConfig = {
      method: 'POST',
      url: config.baseUrl + '/chat/completions',
      headers: {
        ...config.headers,
        'Authorization': config.authToken
      },
      data: {
        model: config.model,
        messages: [{ role: 'user', content: 'Hello' }],
        max_tokens: 10
      },
      timeout: 5000
    };

    // å‘é€æµ‹è¯•è¯·æ±‚
    const response = await axios(testConfig);

    return {
      success: true,
      message: 'è¿žæŽ¥æˆåŠŸï¼',
      model: response.data.model || config.model,
      usage: response.data.usage
    };
  } catch (error) {
    return {
      success: false,
      message: `è¿žæŽ¥å¤±è´¥: ${error.message}`,
      details: error.response?.data || null
    };
  }
});

ipcMain.handle('detect-claude-cli', async () => {
  try {
    const { spawn } = require('child_process');

    return new Promise((resolve) => {
      const process = spawn('claude', ['--version'], {
        stdio: 'pipe'
      });

      let output = '';
      process.stdout.on('data', (data) => {
        output += data.toString();
      });

      process.on('close', (code) => {
        resolve({
          installed: code === 0,
          version: output.trim() || null
        });
      });

      process.on('error', () => {
        resolve({
          installed: false,
          version: null
        });
      });
    });
  } catch (error) {
    return {
      installed: false,
      version: null
    };
  }
});

ipcMain.handle('install-claude-cli', async () => {
  try {
    const { spawn } = require('child_process');
    const platform = os.platform();

    let installCommand;
    if (platform === 'darwin') {
      installCommand = spawn('brew', ['install', 'anthropics/claude']);
    } else if (platform === 'win32') {
      installCommand = spawn('npm', ['install', '-g', '@anthropic-ai/claude-cli']);
    } else {
      installCommand = spawn('npm', ['install', '-g', '@anthropic-ai/claude-cli']);
    }

    return new Promise((resolve) => {
      let output = '';
      let errorOutput = '';

      installCommand.stdout.on('data', (data) => {
        output += data.toString();
      });

      installCommand.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      installCommand.on('close', (code) => {
        resolve({
          success: code === 0,
          output: output,
          error: errorOutput
        });
      });
    });
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
});

ipcMain.handle('save-config', async (event, config) => {
  try {
    const configPath = getClaudeConfigPath();
    const configDir = path.dirname(configPath);

    // ç¡®ä¿ç›®å½•å­˜åœ¨
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }

    fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
    return true;
  } catch (error) {
    console.error('ä¿å­˜é…ç½®å¤±è´¥:', error);
    throw error;
  }
});

ipcMain.handle('get-settings-path', async () => {
  return getClaudeSettingsPath();
});

ipcMain.handle('get-mcp-path', async () => {
  return getClaudeConfigPath();
});

ipcMain.handle('backup-config', async () => {
  try {
    const settingsPath = getClaudeSettingsPath();
    if (fs.existsSync(settingsPath)) {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupPath = settingsPath.replace('.json', `.backup.${timestamp}.json`);
      fs.copyFileSync(settingsPath, backupPath);
      return backupPath;
    }
    return null;
  } catch (error) {
    console.error('å¤‡ä»½é…ç½®å¤±è´¥:', error);
    throw error;
  }
});

// é€‰æ‹©é…ç½®æ–‡ä»¶
ipcMain.handle('select-config-file', async () => {
  try {
    const result = await dialog.showOpenDialog(mainWindow, {
      title: 'é€‰æ‹©Claudeé…ç½®æ–‡ä»¶',
      filters: [
        { name: 'JSONæ–‡ä»¶', extensions: ['json'] },
        { name: 'æ‰€æœ‰æ–‡ä»¶', extensions: ['*'] }
      ],
      properties: ['openFile']
    });

    if (!result.canceled && result.filePaths.length > 0) {
      return result.filePaths[0];
    }
    return null;
  } catch (error) {
    console.error('é€‰æ‹©æ–‡ä»¶å¤±è´¥:', error);
    throw error;
  }
});

// é€‰æ‹©é…ç½®æ–‡ä»¶ç›®å½•
ipcMain.handle('select-config-directory', async () => {
  try {
    const result = await dialog.showOpenDialog(mainWindow, {
      title: 'é€‰æ‹©Claudeé…ç½®ç›®å½•',
      properties: ['openDirectory']
    });

    if (!result.canceled && result.filePaths.length > 0) {
      return result.filePaths[0];
    }
    return null;
  } catch (error) {
    console.error('é€‰æ‹©ç›®å½•å¤±è´¥:', error);
    throw error;
  }
});

// åˆ›å»ºæ–°é…ç½®æ–‡ä»¶
ipcMain.handle('create-new-settings', async (event, filePath) => {
  try {
    const defaultSettings = {
      profiles: []
    };

    // ç¡®ä¿ç›®å½•å­˜åœ¨
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(filePath, JSON.stringify(defaultSettings, null, 2));
    return true;
  } catch (error) {
    console.error('åˆ›å»ºè®¾ç½®æ–‡ä»¶å¤±è´¥:', error);
    throw error;
  }
});

// åº”ç”¨Provideræ¨¡æ¿
ipcMain.handle('apply-provider-template', async (event, providerKey, apiKey) => {
  try {
    const template = PROVIDER_TEMPLATES[providerKey];
    if (!template) {
      throw new Error('æœªæ‰¾åˆ°Provideræ¨¡æ¿');
    }

    // åˆ›å»ºæ–°çš„profileé…ç½®
    const newProfile = {
      name: template.name,
      fields: { ...template.fields }
    };

    // æ›¿æ¢API_KEYå ä½ç¬¦
    Object.keys(newProfile.fields).forEach(key => {
      if (newProfile.fields[key] === '{{API_KEY}}') {
        newProfile.fields[key] = apiKey;
      }
    });

    // è¯»å–çŽ°æœ‰è®¾ç½®
    const settingsPath = getClaudeSettingsPath();
    let settings;
    if (fs.existsSync(settingsPath)) {
      const data = fs.readFileSync(settingsPath, 'utf8');
      settings = JSON.parse(data);
    } else {
      settings = { profiles: [] };
    }

    // ç¡®ä¿profilesæ•°ç»„å­˜åœ¨
    if (!settings.profiles) {
      settings.profiles = [];
    }

    // æ·»åŠ æˆ–æ›´æ–°profile
    const existingIndex = settings.profiles.findIndex(p => p.name === template.name);
    if (existingIndex >= 0) {
      settings.profiles[existingIndex] = newProfile;
    // ä¿å­˜è®¾ç½®
    const settingsDir = path.dirname(settingsPath);

    // ç¡®ä¿ç›®å½•å­˜åœ¨
    if (!fs.existsSync(settingsDir)) {
      fs.mkdirSync(settingsDir, { recursive: true });
    }

    fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2));

    return true;
  } catch (error) {
    console.error('åº”ç”¨Provideræ¨¡æ¿å¤±è´¥:', error);
    throw error;
  }
});

app.whenReady().then(createWindow);

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});